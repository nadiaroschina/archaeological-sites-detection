# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TileLoaderDialog
                                 A QGIS plugin
 Download georeferenced parts of tile map servives
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-05-13
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Pavel Pereverzev
        email                : pasha004@yandex.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import math

import pandas as pd
import requests 
import time 
import json

from PIL import Image

from PyQt5.QtWidgets import QApplication, QWidget, QComboBox, QHBoxLayout, QLineEdit, QGridLayout, QLabel, QPushButton, \
    QMessageBox, QProgressBar, QCheckBox, QSpinBox, QFileDialog

from PyQt5 import QtCore
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from qgis._core import *
from qgis.utils import iface
from qgis.gui import QgsMapToolEmitPoint, QgsRubberBand, QgsMapTool
from qgis.core import QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsPoint, QgsFeature, QgsGeometry, QgsVectorLayer, QgsPointXY, QgsRasterLayer
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets


current_folder = (os.path.dirname(os.path.realpath(__file__)))
cfg_file = os.path.join(current_folder, 'cfg.json')

headers = {
    'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
    'User-Agent': 'M',
    'accept-encoding': 'gzip, deflate',
    'accept-language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7,uk;q=0.6'
}
out_format = 'jpeg'

# I had to remove OSM url due to their request. 
# You are free to edit this dict to get tiles from another sources
dict_sources = {
    "Google BaseMap": {"url":"https://mt1.google.com/vt/lyrs=m&x={0}&y={1}&z={2}", "zmax":21},
    "Google Terrain": {"url":"https://mt1.google.com/vt/lyrs=p&x={0}&y={1}&z={2}", "zmax":20},
    "Google Traffic": {"url":"https://mt1.google.com/vt?lyrs=h@159000000,traffic|seconds_into_week:-1&style=3&x={0}&y={1}&z={2}", "zmax":20},
    "Google Satellite": {"url":"https://khms1.googleapis.com/kh?v=966&hl=en-US&x={0}&y={1}&z={2}", "zmax":20},
    "Google Hybrid": {"url":"https://mt1.google.com/vt/lyrs=y&x={0}&y={1}&z={2}", "zmax":20},
    "ESRI BaseMap": {"url":"https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{2}/{1}/{0}", "zmax":20},
    "ESRI Terrain": {"url":"https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{2}/{1}/{0}", "zmax":20},
    "ESRI Satellite": {"url":"https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{2}/{1}/{0}", "zmax":20},
    "Yandex BaseMap": {"url":"https://core-renderer-tiles.maps.yandex.net/tiles?l=map&v=21.07.13-0-b210701140430&x={0}&y={1}&z={2}&scale=1&lang=ru_RU", "zmax":21},
    "Yandex Satellite": {"url":"https://core-sat.maps.yandex.net/tiles?l=sat&v=3.1105.0&x={0}&y={1}&z={2}&scale=1.5&lang=ru_RU", "zmax":19},
    "Bing BaseMap": {"url":"https://t0.ssl.ak.dynamic.tiles.virtualearth.net/comp/ch/{0}?mkt=ru-RU&it=G,LC,BX,RL&shading=t&n=z&og=1852&cstl=vbp2&o=jpeg", "zmax":19},
    "Bing Satellite": {"url":"https://t1.ssl.ak.tiles.virtualearth.net/tiles/a{0}.jpeg?g=12225&n=z&prx=1", "zmax":18},
    "Bing Hybrid": {"url":"https://t1.ssl.ak.dynamic.tiles.virtualearth.net/comp/ch/{0}?mkt=ru-RU&it=A,G,RL&shading=t&n=z&og=1852&o=jpeg", "zmax":18},
    "MapZen": {"url":"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{2}/{0}/{1}.png", "zmax":18},
}


def write_cfg(folder, zoom, source, lon_name, lat_name, path_to_coords, bottom_right_coords, upper_left_coords):
    # writing config
    config = {
        "last_folder": folder,
        "last_zoom": zoom,
        "last_source": source,
        "last_lon": lon_name,
        "last_lat": lat_name,
        "last_csv": path_to_coords,
        "last_ul": upper_left_coords,
        "last_br": bottom_right_coords
    }
    with open(cfg_file, "w", encoding='utf-8') as d:
        json.dump(config, d, indent=4, ensure_ascii=False)
    return


def read_cfg():
    # reading config
    if not os.path.isfile(cfg_file):
        write_cfg("", 17, "Google BaseMap", 'lon', 'lat', '', '', '')
    with open(cfg_file, 'r') as fp:
        data = json.load(fp)
    return data


def bing_coor_convert(tile_x, tile_y, zoom):
    # convert tile coordinates to quadkey
    quadkey = ''
    for i in range(zoom, 0, -1):
        digit = 0
        mask = 1 << (i - 1)
        if(tile_x & mask) != 0:
            digit += 1
        if (tile_y & mask) != 0:
            digit += 2
        quadkey += str(digit)
    return quadkey


def bing_coor_convert_reverse(quadkey, zoom):
    # convert quadkey to tile coordinates
    tileX = tileY = 0
    levelOfDetail = len(quadkey)
    for i in range(zoom, 0, -1):
        mask = 1 << (i - 1)
        curkey = quadkey[levelOfDetail - i]
        if curkey == '0':
            pass
        elif curkey == '1':
            tileX += mask
        elif curkey == '2':
            tileY += mask
        elif curkey == '3':
            tileX += mask
            tileY += mask
        else:
            pass 
    return tileX, tileY


def yandex_coor_convert(longitude, latitude):
    # convert world lon lat to MercatorProjectionYandex
    d = longitude * math.pi/180
    m = latitude * math.pi/180
    l = 6378137
    k = 0.0818191908426 
    f = k * math.sin(m)
    h = math.tan(math.pi/4 + m/2)
    j = math.pow(math.tan(math.pi/4 + math.asin(f)/2), k)
    i = h / j
    pnt_x_m = l*d
    pnt_y_m = l*math.log(i)

    lon = (pnt_x_m/20037508.34) * 180
    lat = (pnt_y_m/20037508.34) * 180
    lat = 180 / math.pi * (2 * math.atan(math.exp(lat * math.pi / 180)) - math.pi/ 2)
    return lon, lat


def yandex_coor_convert_reverse(x, y, zoom):
    # convert Yandex tile XY to world long lat to 
    RAD_DEG = 180 / math.pi
    x = x*256.0
    y = y*256.0
    a = 6378137
    c1 = 0.00335655146887969
    c2 = 0.00000657187271079536
    c3 = 0.00000001764564338702
    c4 = 0.00000000005328478445
    z1 = (23 - zoom)
    mercX = (x * math.pow(2, z1))/53.5865938 - 20037508.342789
    mercY = 20037508.342789 - (y * math.pow(2, z1)) / 53.5865938
    g = math.pi/ 2 - 2 * math.atan(1 / math.exp(mercY / a))
    z = g + c1 * math.sin(2 * g) + c2 * math.sin(4 * g) + c3 * math.sin(6 * g) + c4 * math.sin(8 * g)
    Y = z * RAD_DEG
    X = mercX / a * RAD_DEG
    return X, Y


def getxy(longitude, latitude, zoom, tileSize):
    # get tile xy coordinates from world lon lat
    sinLatitude = math.sin(latitude * math.pi/180)
    pixelX = ((longitude + 180) / 360) * tileSize * math.pow(2, zoom)
    pixelY = (0.5 - math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * math.pi)) * tileSize * math.pow(2, zoom)
    tileX = math.floor(pixelX / tileSize)
    tileY = math.floor(pixelY / tileSize)
    
    return tileX, tileY


def getxy_reverse(tilelX, tileY, zoom, tileSize):
    # convert tile XY to world coodinates
    longitude = tilelX/math.pow(2, zoom)*360 - 180
    n = math.pi-2*math.pi*tileY/math.pow(2, zoom)
    latitude = 180/math.pi* math.atan(0.5 * (math.exp(n) - math.exp(-1*n)))
    
    return longitude, latitude


class rband(QgsMapToolEmitPoint):
    """rubberband object"""
    def __init__(self, canvas, app):
        self.canvas = canvas
        self.app = app
        self.isEmittingPoint = False
        self.start_pos_x = None
        self.start_pos_y = None
        self.end_pos_x = None
        self.end_pos_y = None
        
        QgsMapToolEmitPoint.__init__(self, self.canvas)
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rubberBand.setColor(QColor(55, 150, 200, 150))
        self.rubberBand.setWidth(3)
        self.rubberBand.reset()
    
    def canvasPressEvent(self, e):
        # start drawing handler
        self.startPoint = self.toMapCoordinates(e.pos())
        self.endPoint = self.startPoint
        self.isEmittingPoint = True
        self.showRect(self.startPoint, self.endPoint)
    
    def canvasMoveEvent(self, e):
        # draw rectangle on move
        if not self.isEmittingPoint:
            return
        self.endPoint = self.toMapCoordinates(e.pos())
        self.showRect(self.startPoint, self.endPoint)
    
    def canvasReleaseEvent(self, e):
        # finish rectangle, miximize main widget
        self.isEmittingPoint = False
        canvasGeom = self.rubberBand.asGeometry()
        self.app.setWindowState(Qt.WindowNoState)
        self.app.btn_save_frame.setDisabled(False)
        self.app.activate_dl()
        self.deactivate()
    
    def showRect(self, startPoint, endPoint):
        # draw rectangle 
        self.rubberBand.reset(QgsWkbTypes.PolygonGeometry)
        if startPoint.x() == endPoint.x() or startPoint.y() == endPoint.y():
            return
        pnts = [
            (startPoint.x(), startPoint.y()),
            (startPoint.x(), endPoint.y()),
            (endPoint.x(), endPoint.y()),
            (endPoint.x(), startPoint.y()),
            (startPoint.x(), startPoint.y())
        ]
        polygon_coors = [QgsPointXY(p[0], p[1]) for p in pnts]
        geom_polygon = QgsGeometry().fromPolygonXY([polygon_coors])
        
        self.start_pos_x = min(pnts, key=lambda v: v[0])[0]
        self.start_pos_y = max(pnts, key=lambda v: v[1])[1]

        self.end_pos_x = max(pnts, key=lambda v: v[0])[0]
        self.end_pos_y = min(pnts, key=lambda v: v[1])[1]

        self.rubberBand.setToGeometry(geom_polygon)
        
    def deactivate(self):
        QgsMapTool.deactivate(self)
        self.deactivated.emit()


class MapTileLoader(QWidget):
    """ Main widget"""
    def __init__(self, parent=None):
        super(MapTileLoader, self).__init__(parent)
        self.setWindowFlags(QtCore.Qt.Dialog)
        self.resize(500, 500)
        self.setWindowTitle("MapTileLoader")
        self.draw_tool = None
        self.tr = None
        self.tr_reversed = None
        self.grid = QGridLayout()
        self.grid.setSpacing(10)
        self.setLayout(self.grid)
        self.work_folder = ''

        # widgets
        self.label_source = QLabel("Source:")
        self.source_cmbx = QComboBox()

        self.label_zoom = QLabel("Zoom level:")
        self.zoom_slider = QSpinBox()
        self.zoom_slider.setMinimum(1)
        self.zoom_slider.setMaximum(24)
        self.zoom_slider.setValue(11)

        self.label_path_coords = QLabel("Csv with coordinates:")
        self.path_line_coords = QLineEdit()
        self.btn_folder_select_coords = QPushButton("...")
        self.btn_folder_select_coords.setMaximumWidth(30)

        self.label_lon_name = QLabel("Lon name in csv:")
        self.lon_name = QLineEdit()

        self.label_lat_name = QLabel("Lat name in csv:")
        self.lat_name = QLineEdit()

        self.label_up_left = QLabel("Upper left corner of rectangle in form: 'lon, lat' "
                                    "(use it and not csv if provided):")
        self.upper_left_coords = QLineEdit()

        self.label_bot_right = QLabel("Bottom right corner of rectangle:")
        self.bottom_right_coords = QLineEdit()

        self.label_path = QLabel("Save to:")
        self.path_line = QLineEdit()
        self.btn_folder_select = QPushButton("...")
        self.btn_folder_select.setMaximumWidth(30)

        self.label_add_rect = QLabel("Frame:")
        self.btn_add_rect = QPushButton("+")
        self.btn_save_frame = QPushButton("Save frame")
        self.btn_load_frame = QPushButton("Load frame")

        self.btn_load = QPushButton("Download")
        self.add_checkbox = QCheckBox("Add image on load")

        self.pbar = QProgressBar()

        # setting up interface
        self.grid.addWidget(self.label_source,       0, 1, 1, 5)
        self.grid.addWidget(self.source_cmbx,        1, 1, 1, 5)

        self.grid.addWidget(self.label_zoom,         2, 1, 1, 5)
        self.grid.addWidget(self.zoom_slider,        3, 1, 1, 5)

        self.grid.addWidget(self.label_path_coords,        4, 1, 1, 5)
        self.grid.addWidget(self.path_line_coords,         5, 1, 1, 4)
        self.grid.addWidget(self.btn_folder_select_coords, 5, 5, 1, 1)

        self.grid.addWidget(self.label_lon_name,           6, 1, 1, 5)
        self.grid.addWidget(self.lon_name,                 7, 1, 1, 4)

        self.grid.addWidget(self.label_lat_name,           8, 1, 1, 5)
        self.grid.addWidget(self.lat_name,                 9, 1, 1, 4)

        self.grid.addWidget(self.label_up_left,            10, 1, 1, 5)
        self.grid.addWidget(self.upper_left_coords,        11, 1, 1, 4)

        self.grid.addWidget(self.label_bot_right,          12, 1, 1, 5)
        self.grid.addWidget(self.bottom_right_coords,      13, 1, 1, 4)

        self.grid.addWidget(self.label_path,               14, 1, 1, 5)
        self.grid.addWidget(self.path_line,                15, 1, 1, 4)
        self.grid.addWidget(self.btn_folder_select,        15, 5, 1, 1)

        self.grid.addWidget(self.btn_load,                 16, 1, 1, 5)
        self.grid.addWidget(self.pbar,                     17, 1, 1, 5)

        # adding map sources
        self.source_cmbx.addItems(list(dict_sources.keys()))

        # setting fucntions to widget signals
        self.source_cmbx.currentTextChanged.connect(self.set_max_zoom)

        self.btn_folder_select_coords.clicked.connect(self.select_folder_coords)

        self.path_line.textChanged.connect(self.activate_dl)
        self.btn_folder_select.clicked.connect(self.select_folder)
        self.btn_load.clicked.connect(self.load)

        # disabling buttons until frame is drawn and path is printed
        self.btn_save_frame.setDisabled(True)
        self.btn_load.setDisabled(False)

        self.proj_transforms()
        self.set_config()
        self.show()

    def warning_message(self, err_text):
        # custom warning message
        msg = QMessageBox()
        msg.warning(self, "Warning", err_text)
        return

    def set_config(self):
        # set config on previous use
        config = read_cfg()
        idx_source = list(dict_sources.keys()).index(config['last_source'])
        zoom = config['last_zoom']
        folder = config['last_folder']
        lon_name = config['last_lon']
        lat_name = config['last_lat']
        path_to_coords = config['last_csv']
        br_coords = config['last_br']
        ul_coords = config['last_ul']
        self.source_cmbx.setCurrentIndex(idx_source)
        self.zoom_slider.setValue(zoom)
        self.path_line.setText(folder)
        self.lon_name.setText(lon_name)
        self.lat_name.setText(lat_name)
        self.path_line_coords.setText(path_to_coords)
        self.bottom_right_coords.setText(br_coords)
        self.upper_left_coords.setText(ul_coords)

    def set_max_zoom(self):
        # set maximum tile source level
        current_source = self.source_cmbx.currentText()
        max_zoom = dict_sources[current_source]['zmax']
        self.zoom_slider.setMaximum(max_zoom)

    def select_folder(self):
        # select folder for output rasters
        result = QFileDialog.getExistingDirectory(self, 'Select Folder')
        if result:
            self.path_line.setText(result)
        return

    def select_folder_coords(self):
        # select csv file with
        result = QFileDialog.getOpenFileName(self, 'Select csv file')
        if result:
            self.path_line_coords.setText(result[0])
            self.path_to_coords = result[0]
        return

    def activate_dl(self):
        # check if rectangle is drawn and path is pointed
        # if yes then make download button enabled
        cur_path = self.path_line.text()
        if not cur_path:
            self.btn_load.setDisabled(True)
        else:
            self.btn_load.setDisabled(False)
        return

    def check_folder(self):
        # check if folder exists
        path = self.path_line.text()
        if os.path.isdir(path):
            self.work_folder = path
            return True
        return False

    def draw_rect(self):
        # running rect tool
        if self.draw_tool:
            self.draw_tool.rubberBand.reset()
            self.draw_tool = None
        self.draw_tool = rband(iface.mapCanvas(), self)
        iface.mapCanvas().setMapTool(self.draw_tool) 
        self.showMinimized()

    def proj_transforms(self):
        current_crs = QgsProject.instance().crs() 
        sourceCrs = QgsCoordinateReferenceSystem(current_crs)
        destCrs = QgsCoordinateReferenceSystem(4326)
        self.tr = QgsCoordinateTransform(sourceCrs, destCrs, QgsProject.instance())
        self.tr_reversed = QgsCoordinateTransform(destCrs, sourceCrs, QgsProject.instance())

    def rband_coors(self):
        # transforming rectangle coordinates into project crs
        if self.draw_tool:
            pnt_start = QgsPointXY(self.draw_tool.start_pos_x, self.draw_tool.start_pos_y)
            pnt_end = QgsPointXY(self.draw_tool.end_pos_x, self.draw_tool.end_pos_y) 
            # print('old', self.draw_tool.startPoint, self.draw_tool.endPoint)
            # print('new', pnt_start, pnt_end)
            pnt_geom_start = QgsGeometry().fromPointXY(pnt_start)
            pnt_geom_end  = QgsGeometry().fromPointXY(pnt_end)
            
            pnt_geom_start.transform(self.tr)
            pnt_geom_end.transform(self.tr)
            return pnt_geom_start, pnt_geom_end

    def load(self):
        # initializing download
        self.get_raster(self.zoom_slider.value())

    def download_file(self, lon_start, lat_start, zoom, number=0):
        # lon_start, lat_start = 33.08707, 25.05003
        # lon_start, lat_start = pnt_start.asPoint().x(), pnt_start.asPoint().y()
        # lon_end, lat_end = pnt_end.asPoint().x(), pnt_end.asPoint().y()
        f_name_pref = '{}-{}'.format(round(lon_start, 2), round(lat_start, 2)).replace('.', '_')

        tileSize = 256
        current_source = self.source_cmbx.currentText()

        # yandex
        if 'yandex' in current_source.lower():
            lon_start, lat_start = yandex_coor_convert(lon_start, lat_start)
            # lon_end, lat_end = yandex_coor_convert(lon_end, lat_end)

        xy_start = getxy(lon_start, lat_start, zoom, tileSize)
        # xy_end = getxy(lon_end, lat_end, zoom, tileSize)

        dt = getxy_reverse(xy_start[0], xy_start[1], zoom, 256)
        # et = getxy_reverse(xy_end[0]+1, xy_end[1]+1, zoom, 256)

        # yandex
        if 'yandex' in current_source.lower():
            dt = yandex_coor_convert_reverse(xy_start[0], xy_start[1], zoom)
            # et = yandex_coor_convert_reverse(xy_end[0]+1, xy_end[1]+1, zoom)

        xmin = xy_start[0]
        ymin = xy_start[1]
        # xmax = xy_end[0]
        # ymax = xy_end[1]

        self.download_file_xy(xmin, ymin, zoom, number)

    def download_file_xy(self, xmin, ymin, zoom, number=0):
        tileSize = 256
        current_source = self.source_cmbx.currentText()
        tile_url = dict_sources[current_source]['url']

        session = requests.Session()
        files_list = []

        if 'bing' in current_source.lower():
            quadkey = bing_coor_convert(xmin, ymin, zoom)
            lnk_download = tile_url.format(quadkey)
        else:
            lnk_download = tile_url.format(xmin, ymin, zoom)

        file_out = os.path.join(self.work_folder, f'{str(number).zfill(6)}.jpeg')

        if not os.path.isfile(file_out):
            xy_orig = getxy_reverse(xmin, ymin, zoom, tileSize)
            if 'yandex' in current_source.lower():
                xy_orig = yandex_coor_convert_reverse(xmin, ymin, zoom)

            request = session.get(lnk_download, headers=headers)
            if request.status_code == 404:
                raise Exception('404')
                img = Image.new("RGB", (256, 256), (255, 255, 255))
                img.save(file_out, "JPEG")
            elif request.status_code == 403:
                raise Exception
            else:
                with open(file_out, 'wb') as out:
                    out.write(request.content)
                # file_out_logs = file_out.split('.')[0] + '.txt'
                # with open(file_out_logs, 'w') as out:
                #     out.write(str(request.status_code))
            time.sleep(.1)
            files_list.append(file_out)

            QtCore.QCoreApplication.processEvents()

    def get_raster(self, zoom):
        # get tiles and stitch them into one georeferenced image
        folder_valid = self.check_folder()
        if not folder_valid:
            self.warning_message("Folder does not exist")
            return

        current_source = self.source_cmbx.currentText()

        path_to_coords = self.path_line_coords.text()
        lon_name = self.lon_name.text()
        lat_name = self.lat_name.text()
        bottom_right_coords = self.bottom_right_coords.text()
        upper_left_coords = self.upper_left_coords.text()

        df = pd.read_csv(path_to_coords, index_col=None)
        write_cfg(self.work_folder, zoom, current_source, lon_name, lat_name, path_to_coords,
                  bottom_right_coords, upper_left_coords)

        if upper_left_coords != '':
            lon_start, lat_start = tuple(float(c.strip()) for c in upper_left_coords.split(','))
            lon_end, lat_end = (float(c.strip()) for c in bottom_right_coords.split(','))
            tileSize = 256
            current_source = self.source_cmbx.currentText()

            # yandex
            if 'yandex' in current_source.lower():
                lon_start, lat_start = yandex_coor_convert(lon_start, lat_start)
                lon_end, lat_end = yandex_coor_convert(lon_end, lat_end)

            xy_start = getxy(lon_start, lat_start, zoom, tileSize)
            xy_end = getxy(lon_end, lat_end, zoom, tileSize)

            xmin = xy_start[0]
            ymin = xy_start[1]
            xmax = xy_end[0]
            ymax = xy_end[1]

            counts = (ymax - (ymin - 1)) * ((xmax + 1) - xmin)
            step_pbar = 100 / counts
            step_counter = 0

            for y_step in range(ymax, ymin - 1, -1):
                for x_step in range(xmin, xmax + 1, 1):
                    self.download_file_xy(x_step, y_step, zoom, step_counter)
                    step_counter += 1
                    self.pbar.setValue(step_counter * step_pbar)
        else:
            counts = len(df)
            step_pbar = 100 / counts
            step_counter = 0
            for index, row in df.iterrows():
                self.download_file(row[lon_name], row[lat_name], zoom, step_counter)
                step_counter += 1
                self.pbar.setValue(step_counter * step_pbar)
        return

    def save_frame(self):
        # save current drawn rectangle to *.xtnt file
        if self.draw_tool:
            self.pnt_geom_start, self.pnt_geom_end = self.rband_coors()
            name = QFileDialog.getSaveFileName(self, 'Save Frame', "", "xtnt (*.xtnt)")
            if name[0]:
                data = [(p.asPoint().x(), p.asPoint().y()) for p in [self.pnt_geom_start, self.pnt_geom_end]]
                data_str = "\n".join(["{},{}".format(p[0], p[1])  for p in data])
                with open(name[0], 'w') as wfile:
                    wfile.write(data_str)
        return

    def load_frame(self):
        # load rectangle coordinates from *.xtnt file
        f_open = QFileDialog.getOpenFileName(self, "Select Frame", "", "*.xtnt")
        if f_open[0]:
            lines = []
            with open(f_open[0], 'r') as rfile:
                lines = [line.rstrip() for line in rfile]
            uw_pnt = [float(p) for p in lines[0].split(',')]
            le_pnt = [float(p) for p in lines[1].split(',')]
            
            start_point = QgsPointXY(uw_pnt[0], uw_pnt[1])
            end_point = QgsPointXY(le_pnt[0], le_pnt[1])
            
            start_point_geom = QgsGeometry().fromPointXY(start_point)
            end_point_geom = QgsGeometry().fromPointXY(end_point)
            
            start_point_geom.transform(self.tr_reversed)
            end_point_geom.transform(self.tr_reversed)

            start_point_projected = start_point_geom.asPoint()
            end_point_projected = end_point_geom.asPoint()

            if self.draw_tool:
                self.draw_tool.rubberBand.setToGeometry(geom_polygon)
            else:
                self.draw_tool = rband(iface.mapCanvas(), self)
                iface.mapCanvas().setMapTool(self.draw_tool) 
                self.draw_tool.showRect(start_point_projected, end_point_projected)
                self.draw_tool.startPoint = start_point_projected
                self.draw_tool.endPoint = end_point_projected
            self.activate_dl()

        return

    def closeEvent(self, event):
        # remove all rubberbands
        if self.draw_tool:
            self.draw_tool.rubberBand.reset()
            self.draw_tool.deactivate()
            iface.mapCanvas().unsetMapTool(self.draw_tool)
